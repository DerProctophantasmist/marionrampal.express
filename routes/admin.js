// Generated by CoffeeScript 2.5.1
(function() {
  var VErr, commit, createGlobalCache, doCache, doneCaching, doneCommit, doneUnstage, editFile, entryFile, exec, express, filepath, folder, formParser, fs, log, mainLog, onInit, path, postUpload, preUpload, prodDir, renderError, router, stagingDir, storage, unstage, upload, vasync;

  express = require('express');

  router = express.Router();

  editFile = express.Router();

  vasync = require('vasync');

  VErr = require('verror');

  exec = require('child_process').execFile;

  log = mainLog = require('../helpers/logger').mainLogger;

  fs = require('file-system');

  path = require('path');

  formParser = require('multer');

  require('../helpers/marked.utils');

  ({createGlobalCache} = require('../helpers/cache'));

  prodDir = null;

  stagingDir = null;

  entryFile = null;

  renderError = function(err) {
    return log.error(err);
  };

  folder = function(subDir) {
    return {
      cleanup: function(callback) {
        if (prodDir === null) {
          throw new VErr("config not loaded.");
        }
        return exec('rm', ['-rf', prodDir + '/' + subDir], function(err, stdout, stderr) {
          return callback(err, {stdout, stderr});
        });
      },
      sync: function(callback) {
        if (prodDir === null) {
          throw new VErr("config not loaded.");
        }
        return exec('rsync', ['-a', '--delete', stagingDir + '/' + subDir + '/', prodDir + '/' + subDir], function(err, stdout, stderr) {
          return callback(err, {stdout, stderr});
        });
      },
      unstage: function(callback) {
        if (prodDir === null) {
          throw new VErr("config not loaded.");
        }
        return exec('rsync', ['-a', '--delete', prodDir + '/' + subDir + '/', stagingDir + '/' + subDir], function(err, stdout, stderr) {
          return callback(err, {stdout, stderr});
        });
      }
    };
  };

  filepath = function(rootDir, filepath) {
    var absPath, file, filter;
    filter = fs.fileMatch(stagingDir + '/data/**/*.md');
    absPath = path.join(rootDir, filepath);
    log.info({
      "full path": absPath
    });
    file = {
      mayWrite: function() {
        return filter(absPath);
      },
      full: function() {
        return absPath;
      }
    };
    return file;
  };

  commit = function(req, res, next) {
    var data, images;
    log = require('../helpers/logger').requestLogger(req);
    renderError = function(err) {
      log.error(err);
      return res.status(500).json({
        txt: err.message,
        status: 'fail'
      });
    };
    data = folder('data');
    images = folder('images');
    vasync.parallel({
      'funcs': [data.sync, images.sync]
    }, doneCommit(req, res, next));
  };

  unstage = function(req, res, next) {
    var data, images;
    log = require('../helpers/logger').requestLogger(req);
    renderError = function(err) {
      log.error(err);
      return res.status(500).json({
        txt: err.message,
        status: 'fail'
      });
    };
    data = folder('data');
    images = folder('images');
    vasync.parallel({
      'funcs': [data.unstage, images.unstage]
    }, doneUnstage(req, res, next));
  };

  doneCommit = function(req, res, next) {
    return function(err, results) {
      if (err) {
        return renderError(new VErr(err, "Failed to commit changes"));
      } else {
        return next();
      }
    };
  };

  doneUnstage = function(req, res, next) {
    return function(err, results) {
      if (err) {
        return renderError(new VErr(err, "Failed to unstage"));
      } else {
        return res.render('ok', {
          message: "Data and images of the staging area have been reset to match production website"
        });
      }
    };
  };

  doCache = function(req, res, next) {
    return createGlobalCache(`${prodDir}/data/`, entryFile, doneCaching(req, res, next));
  };

  doneCaching = function(req, res, next) {
    return function(err, results) {
      if (err) {
        return renderError(new VErr(err, "Failed to cache commited data "));
      } else {
        require('../helpers/init').setCompileDate();
        return res.render('ok', {
          message: "Data and images of the staging area have been commited and cached."
        });
      }
    };
  };

  preUpload = function(req, res, next) {
    var dest, mayWrite;
    log = require('../helpers/logger').requestLogger(req);
    renderError = function(err) {
      log.error(err);
      return res.status(400).json({
        txt: err.message,
        status: 'fail'
      });
    };
    req.dest = req.params[0];
    dest = filepath(stagingDir + '/data', req.dest);
    req.dest = dest.full();
    mayWrite = dest.mayWrite();
    log.info("requested edit: %s maywrite: %s", req.dest, mayWrite);
    if (mayWrite) {
      return next();
    } else {
      return res.status(403).send(VErr("May not write to %s", req.dest));
    }
  };

  storage = formParser.diskStorage({
    destination: function(req, file, cb) {
      var dir;
      dir = path.dirname(req.dest);
      return fs.mkdir(dir, function(err) {
        return cb(err, dir);
      });
    },
    filename: function(req, file, cb) {
      return cb(null, path.basename(req.dest));
    }
  });

  upload = formParser({
    storage: storage
  });

  postUpload = function(req, res, next) {
    res.status(200).send("ok");
  };

  onInit = function(_, config) {
    //todo: add a middleware in app.js that adds the config object to req so that it is accessible from the callbacks without hassle
    // for now hack it with globals:
    prodDir = config.prodPublicDir;
    stagingDir = config.stagingPublicDir;
    entryFile = config.entryFile;
    if (prodDir === null || stagingDir === null) {
      throw new VErr("config not loaded.");
    }
    // commit changes in the staging area to the production website: 
    router.post('/commit', commit, doCache);
    router.post('/unstage', unstage);
    return router.post('/editfile/*', preUpload, upload.single("file"), postUpload);
  };

  require('../helpers/init').readConfig(onInit);

  module.exports = router;

}).call(this);

//# sourceMappingURL=admin.js.map
